import { StandaloneService } from '@abstracts/service-base/StandaloneService';
import type { Logger } from '@components/shared/LoggerComponent';
import { TRANSFER_HOST } from '@config/core.config';
import { REQUEST_TIMEOUT } from '@config/network.config';
import { injectInitializator } from '@decorators/injectInitializator.decorator';
import { injectLogger } from '@decorators/injectLogger.decorator';
import { HttpStatus } from '@game/shared';
import { NetworkEvents } from '@gametypes/event.types';

@injectLogger()
@injectInitializator(async (_: NetworkService) => {})
export class NetworkService extends StandaloneService {
	private declare logger: Logger;
	public declare init: () => void;

	private _online = true;
	public get isOnline() {
		return this._online;
	}

	constructor(private events: Phaser.Events.EventEmitter) {
		super();
	}

	public async request(endpoint: string, options: RequestInit = {}): Promise<Response> {
		if (!this._online) {
			this.logger.warn('Запрос заблокирован: нет сети');
			return this.createErrorResponse(HttpStatus.ServiceUnavailable);
		}

		const url = `${TRANSFER_HOST}${endpoint}`;
		const headers = {
			'Content-Type': 'application/json',
			...options.headers,
		};

		const config: RequestInit = {
			...options,
			headers,
			signal: AbortSignal.timeout(REQUEST_TIMEOUT),
		};

		try {
			const response = await fetch(url, config);

			if (response.status >= 500) {
				throw new Error(`Server Error: ${response.status}`);
			}

			return response;
		} catch (error) {
			return this.handleNetworkError(error);
		}
	}

	public async fetch<T>(endpoint: string, options: RequestInit = {}): Promise<T> {
		const response = await this.request(endpoint, options);

		if (!response.ok) {
			return null;
		}

		try {
			return (await response.json()) as T;
		} catch (e) {
			this.logger.quietError('Ошибка парсинга JSON:', e);
			return null;
		}
	}

	public ping() {
		return this.request('/api/probing/ping');
	}

	private handleNetworkError(error: unknown): Response {
		this.logger.quietError('Network Error:', error);

		if (this._online) {
			this.goOffline();
		}

		return this.createErrorResponse(HttpStatus.InternalServerError);
	}

	private goOffline() {
		if (!this._online) return;

		this.logger.warn('Connection lost, wwitching to offline mode');
		this._online = false;
		this.events.emit(NetworkEvents.CONNECTION_LOST);
	}

	private createErrorResponse(status: number): Response {
		return new Response(null, { status, statusText: 'Generated by NetworkService' });
	}
}
